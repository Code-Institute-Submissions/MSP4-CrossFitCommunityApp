

async def calc_level_test(request):
    # return await asyncio.gather(calc_level_sync(request))
    bdata = await asyncio.gather(calc_level_sync(request))
    bdata = bdata[0]
    print(bdata)
    general_level = bdata["general_level"]
    cat_levels = bdata["cat_levels"]
    new_levels_html = loader.render_to_string(
    'profiles/includes/herolevel.html',
    {
        "general_level": general_level,
        "cat_levels": cat_levels
    })
    data = {
        'new_levels_html': new_levels_html
    }
    # data = json.loads(data)    
    print("checking data")
    return JsonResponse(data)


@csrf_exempt
@sync_to_async
def calc_level_sync(request):
    if request.is_ajax():
        print("CHECK")
        start_time = time.time()
        if request.POST["user"] == "request":
            user = request.user
        else:
            user = User.objects.get(pk=request.POST["user"])
        users = User.objects.all()
        categories = ["Power Lifts", "Olympic Lifts", "Body Weight", "Heavy", "Light", "Long", "Speed", "Endurance"]
        cat_reverse = {"Power Lifts": "PL", "Olympic Lifts": "OL", "Body Weight": "BW", "Heavy": "HE", "Light": "LI", "Long": "LO", "Speed": "SP", "Endurance": "EN"}
        cat_levels = []
        for cat in categories:
            workouts = Workout.objects.filter(workout_category=cat_reverse[cat])
            percentiles = []
            wod_level = []
            for wod in workouts:
                # percentile = getLevels(request.user, wod)
                data = getLevels(user, wod)
                # data = await asyncio.gather(getLevels(user, wod))
                percentile = data["percentile"]
                result = data["result"]
                if percentile is not None:
                    wod_level.append({"wod": wod.workout_name, "wodperc": percentile, "wodpk": wod.pk, "result": result})
                    # wod_level.append({"wod": wod.workout_name, "wodperc": percentile, "wodpk": wod.pk})
                    percentiles.append(percentile)
            if len(percentiles) >= 3:
                accuracy = "high"
            elif len(percentiles) == 2:
                accuracy = "medium"
            elif len(percentiles) == 1:
                accuracy = "low"
            else:
                accuracy = "none"
            if accuracy != "none":
                avg_percentile = round(statistics.mean(percentiles))
            else:
                avg_percentile = "none"
            cat_levels.append({"cat": cat, "perc": avg_percentile, "acc": accuracy, "wod_level": wod_level})
        print("HALFWAY " + user.username)
        avg_list = []
        for item in cat_levels:
            if item["perc"] != "none":
                avg_list.append(item["perc"])
        if len(avg_list) != 0:
            general_level = round(statistics.mean(avg_list))
        else:
            general_level = 0
        level_data = HeroLevels.objects.filter(user=user)
        level_data.update(level_data=cat_levels)
        level_data.update(general_level=general_level)
        # new_levels_html = loader.render_to_string(
        # 'profiles/includes/herolevel.html',
        # {
        #     "general_level": general_level,
        #     "cat_levels": cat_levels
        # })
        # data = {
        #     'new_levels_html': new_levels_html
        # }
        data = {
            "general_level": general_level,
            "cat_levels": cat_levels
        }
        print("SUCCESS "  + user.username)
        total = (time.time() -  start_time)
        print("total time: ", total)
        # return JsonResponse(data)
        # data = str(json.dumps(data))
        return data
    else:
        print("FAILED HERE")
        data = {"message": "Failed update"}
        return HttpResponse(json.dumps(data), content_type='application/json')


# def calc_level(request):
#     t = Thread(target=calc_level_thr(request))
#     t.start()
#     data = t.join()
#     return data
    

     # rank = 0
    # prevresult = [0, 0]
    # # all_gender_index = 1
    # rlistgenderall = []
    # user_rank = 0
    # for log in all_logs_rank:
    #     if getattr(log, rank_result) == prevresult[0]:
    #         prevresult[1] += 1
    #     else:
    #         rank = rank + 1 + prevresult[1]
    #         prevresult[1] = 0
    #     prevresult[0] = getattr(log, rank_result)
    #     # prevresult[0] =log.mw_result
    #     rlistgenderall.append([log.pk, rank])
    #     if log.user == user:
    #         # all_gender_index_user = all_gender_index
    #         user_rank = rank
    #     # else:
    #         # all_gender_index += 1
    # if user_rank != 0:
    #     last_rank = rlistgenderall[-1][1]
    #     percentile = round((1-(user_rank/last_rank)) * 100)
    # else:
    #     percentile = None
    # return percentile


# @csrf_exempt
# def getPersonalHistory(request):
#     page = request.POST["page"]
#     # create list of all user id's
#     member_comments = MemberComment.objects.filter(log_id__user=request.user)
#     all_logs = Log.objects.all().order_by('-date')
#     calling_group = all_logs.filter(user=request.user)
#     # user_logs[:25]
#     # check for superuser
#     no_page = False
#     superuser = False
#     if request.user.is_superuser:
#         superuser = True
#     profile = request.user
#     results_per_page = 25
#     paginator_calling_group = Paginator(calling_group, results_per_page)
#     try:
#         calling_group = paginator_calling_group.page(page)
#     except PageNotAnInteger:
#         calling_group = paginator_calling_group.page(2)
#     except EmptyPage:
#         print("ERROR LAST PAGE")
#         calling_group = paginator_calling_group.page(paginator_calling_group.num_pages)
#         no_page = True
#     calling_group_html = loader.render_to_string(
#         'profiles/includes/personal_history.html',
#         {
#         'h_group': calling_group,
#         'member_comments':member_comments,
#         'superuser': superuser,
#         "profile": profile,
#         "no_page": no_page
#         }
#     )
#     # package output data and return it as a JSON object
#     output_data = {
#         'calling_group_html': calling_group_html,
#         'has_next': calling_group.has_next()
#     }
#     return JsonResponse(output_data)